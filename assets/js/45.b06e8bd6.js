(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{257:function(_,v,l){"use strict";l.r(v);var o=l(0),t=Object(o.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var _=this,v=_.$createElement,l=_._self._c||v;return l("div",{staticClass:"content"},[l("blockquote",[l("p",[_._v("与bfs相似，")])]),_._v(" "),l("ol",[l("li",[_._v("岛屿的最大面积")])]),_._v(" "),l("blockquote",[l("p",[_._v("给你一个大小为 m x n 的二进制矩阵 grid 。\n​")])]),_._v(" "),l("blockquote",[l("p",[_._v("岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。\n​")])]),_._v(" "),l("blockquote",[l("p",[_._v("岛屿的面积是岛上值为 1 的单元格的数目。\n​")])]),_._v(" "),l("blockquote",[l("p",[_._v("计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。")])]),_._v(" "),l("ol",[l("li",[_._v("找到任意一个岛屿的任意位置p0，将p0入栈。")]),_._v(" "),l("li",[_._v("循环出栈，对于每个出栈的位置q0\n"),l("ol",[l("li",[_._v("将q0进行标记，标记为已入栈")]),_._v(" "),l("li",[_._v("将q0的所有未标记的可延伸方向入栈")])])]),_._v(" "),l("li",[_._v("栈空时，所有进入过栈的位置p0的总数即为该岛屿的大小")])]),_._v(" "),l("hr"),_._v(" "),l("ol",{attrs:{start:"2"}},[l("li",[_._v("岛屿数量")])]),_._v(" "),l("blockquote",[l("p",[_._v("给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n​")])]),_._v(" "),l("blockquote",[l("p",[_._v("岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n​")])]),_._v(" "),l("blockquote",[l("p",[_._v("此外，你可以假设该网格的四条边均被水包围。")])]),_._v(" "),l("p",[_._v("与上题类似，只是需要记录的是栈空的次数")]),_._v(" "),l("hr"),_._v(" "),l("ol",{attrs:{start:"3"}},[l("li",[_._v("被环绕的区域")])]),_._v(" "),l("blockquote",[l("p",[_._v("给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。")])]),_._v(" "),l("p",[_._v("题目可以变形为：寻找不被4边上的O连接的O，将其填充为X")]),_._v(" "),l("ol",[l("li",[_._v("寻找矩阵board的上下左右四条边上字符为O的位置o1")]),_._v(" "),l("li",[_._v("o1入栈")]),_._v(" "),l("li",[_._v("循环遍历栈，当o1出栈时\n"),l("ol",[l("li",[_._v("将位置o1标志为Y")]),_._v(" "),l("li",[_._v("将其四个方位上为O的位置入栈")])])]),_._v(" "),l("li",[_._v("对矩阵进行遍历\n"),l("ol",[l("li",[_._v("将标志为Y的改成O")]),_._v(" "),l("li",[_._v("将标志为O的改成X")])])])]),_._v(" "),l("hr"),_._v(" "),l("ol",{attrs:{start:"4"}},[l("li",[_._v("太平洋大西洋水流问题")])]),_._v(" "),l("blockquote",[l("p",[_._v("给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。\n​")])]),_._v(" "),l("blockquote",[l("p",[_._v("规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。\n​")])]),_._v(" "),l("blockquote",[l("p",[_._v("请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。")])]),_._v(" "),l("p",[_._v("题目可以变形为：找出太平洋和大西洋的共有源头")]),_._v(" "),l("ol",[l("li",[_._v("对于上边界和左边界上的任一位置入栈")]),_._v(" "),l("li",[_._v("循环出栈，对于出栈的o1\n"),l("ol",[l("li",[_._v("将位置o1标志为x")]),_._v(" "),l("li",[_._v("将其周围标志为非x，并且值大于等于o1的值入栈")])])]),_._v(" "),l("li",[_._v("对有边界和下边界重复1、2操作")]),_._v(" "),l("li",[_._v("对两个标志数组进行比较，重复被标记的点即为共有源头")])])])}],!1,null,null,null);t.options.__file="DFS.md";v.default=t.exports}}]);