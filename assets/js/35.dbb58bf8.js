(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{227:function(_,v,a){"use strict";a.r(v);var t=a(0),i=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("div",{staticClass:"content"},[a("h2",{attrs:{id:"主从同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从同步","aria-hidden":"true"}},[_._v("#")]),_._v(" 主从同步")]),_._v(" "),a("ol",[a("li",[_._v("主库的修改操作记录到binlog")]),_._v(" "),a("li",[_._v("从库启动io线程，同步主库的binlog到自己的delay log")]),_._v(" "),a("li",[_._v("从库的循环thread定时扫描delay log的数据刷到磁盘中")])]),_._v(" "),a("p",[_._v("在步骤二中\n根据同步的情况不同，从库具有不同的可靠性")]),_._v(" "),a("ol",[a("li",[_._v("全提交策略：事务需要等到从库全部同步delay log完毕才提交")]),_._v(" "),a("li",[_._v("半提交策略：事务只需要等待任一个从库同步完delay log完毕后提交")]),_._v(" "),a("li",[_._v("事务不关心从库delay log的同步情况")])]),_._v(" "),a("p",[_._v("根据binlog记录形式的不同，有以下三种分类")]),_._v(" "),a("ol",[a("li",[_._v("row，基于行的修改")]),_._v(" "),a("li",[_._v("修改记录，基于语句的修改")]),_._v(" "),a("li",[_._v("mix，先基于语句的修改，如果不行，再基于行")])]),_._v(" "),a("h2",{attrs:{id:"读写分离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#读写分离","aria-hidden":"true"}},[_._v("#")]),_._v(" 读写分离")]),_._v(" "),a("p",[_._v("情况：请求过多，单个库处理吃力时\n采用主从同步的方案，将db分成主库和从库，主库只接收写请求，从库接收读请求\n如何处理事务？\n对于事务的情况，统一走主库")]),_._v(" "),a("h2",{attrs:{id:"分库分表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分库分表","aria-hidden":"true"}},[_._v("#")]),_._v(" 分库分表")]),_._v(" "),a("p",[_._v("当数据量过大，读写分离方案已经hold不住的时候，这时我们就需要进行分库分表\n方案分为垂直分表和水平分表")]),_._v(" "),a("h3",{attrs:{id:"垂直分表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垂直分表","aria-hidden":"true"}},[_._v("#")]),_._v(" 垂直分表")]),_._v(" "),a("p",[_._v("将一个字段很多的表，拆分成两个表")]),_._v(" "),a("h3",{attrs:{id:"水平分表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#水平分表","aria-hidden":"true"}},[_._v("#")]),_._v(" 水平分表")]),_._v(" "),a("p",[_._v("当表中的数据过多，一般而言，当一次io需要4次（大概在一千万左右），就可以开始考虑采取分表策略。将一个表中的数据，根据一定的规则，拆分成n个表，将这n个表，存放在m个库中\n数据拆分规则：")]),_._v(" "),a("ol",[a("li",[_._v("根据数据量拆分，1~1000W放在表1，1000W~2000W放在表2")]),_._v(" "),a("li",[_._v("根据主键进行hash取模")]),_._v(" "),a("li",[_._v("根据时间拆分，每个月份的数据落一张表")])]),_._v(" "),a("p",[_._v("路由架构")]),_._v(" "),a("ol",[a("li",[_._v("客户端路由，使用sdk的形式，代理数据源（druid、c3p0等），在sdk中，完成hash路由以及数据聚合的功能")])]),_._v(" "),a("p",[_._v("优点：\n缺点：")]),_._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[_._v("服务端路由，在业务与db之间再加一层路由服务，业务直接访问路由层，有路由层与db交互")])]),_._v(" "),a("p",[_._v("优点：\n业务无感\n缺点：")]),_._v(" "),a("ol",[a("li",[_._v("路由需要解决自己的单点问题")]),_._v(" "),a("li",[_._v("多一次io")])]),_._v(" "),a("p",[_._v("拆分后的问题")]),_._v(" "),a("ol",[a("li",[_._v("连表查询")]),_._v(" "),a("li",[_._v("分页查询")])]),_._v(" "),a("p",[_._v("总之，查询不再友好\n替代方案：使用tiDB来代替水平分表")])])}],!1,null,null,null);i.options.__file="集群.md";v.default=i.exports}}]);